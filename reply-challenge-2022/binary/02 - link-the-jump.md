# Link The Jump

## First solution - Exploit rand()
The challenge provides us a Docker container with a Linux 64-bit ELF binary. Opening it with Ghidra we could observe that it first asks for a password.
```
iVar1 = strcmp(local_68,"secret_passwd_anti_bad_guys");
```

Then, the program initializes the random number generator with seed 0:
```
tVar2 = time((time_t *)0x0);
srand((uint)tVar2);
```

and then two functions are called.
The first one, FUN_1013E7(), prints a message and then calls function FUN_1012F2() and in this function there is a call to FUN_101245(5) which generates a random string of 5 characters.
Each character is generated by taking a random character from string `abcdefghijklmopqrstuvwxyz` by generating first a random number with libc's function `rand()`.
FUN_101245 is called 11 times thanks to a for loop, always with 5 as parameter.

Then, it asks for the next move suggesting to use command `Help`:
```
What is your next move? (Help)
>Help
Help            print help menu
Exit            close the connection
Jump            move to the next plant
GetName         get planet name
Rename          rename planet
Check           check if you can overflow the stack
GoBack          move to the previous planet
Search          looking for Zer0
Nap             Get a nap
Admin           Access as Admin
```

to display the menu.

The most interesting commaand is `Admin`, since it reads commands to be passed to the `system()` function.
But before doing it, it asks for a password of 30 characters using the same function used to generate the 11 5 characters strings at the beginning.

From the manual page of `srand` we can see that `Two different initializations with the same seed will generate the same succession of results in subsequent calls to rand.`

So, the plan for the attack is the following:
- Open `libc` in exploit by using `CDLL` python's library
- Connect to the remote service
- Callc `libc.srand` to set the random seed to `libc.time(0)` in order to have locally the same seed used remotely
- Generate 5 * 11 random values in order have the same set of random values generated by the target before creating the password locally
- Generate the password
- `/bin/sh` to get the shell thanks to `system()` or just `ls` and then `cat flag`

![image](https://user-images.githubusercontent.com/32301476/197350696-988ba074-fee7-4044-81cc-0b869a6d819e.png)

## Second solution - Buffer overflow 
In the `Rename` functionality there is a buffer overflow over the current planet name field.

![image](https://user-images.githubusercontent.com/32301476/197352405-d3c883ac-df7e-413c-90fc-27d370c48fcf.png)

In order to win, we need to reach the portion of the program that calls the `system()` function that is protected by the randomly generated password that we have seen in the previous section, moreover, the menu uses a pointer table in the data section to locate the correct method to run `(*(code *)(&PTR_FUN_00104160)[local_70])();`.

So, the attack plan is:
- rename the planet to a 16 char name and then read the name back to leak `dataptr`, leaking ASLR
- rename a planet with 24 plus pointer to the menu function table to overwrite the next pointer
- go to the next planet, now root points to the menu function table
- rename the planet, overwriting the Help proc ptr with the "win" function
- call Help
